\section{Analysis}

Ultimately we want two things. A game engine, and a game editor. The engine is 
not to be modified - a standalone binary, or the like, must be provided, that 
will look in predetermined locations for assets and tie the whole game
together.

Assets contain anything from text, graphics and sounds. Assets can be organized
in subcategories as well, since for example, in games we would like to discern
between background music, and sound effects. This organization is purely
aesthetic, and to help the user navigate through many things. Assets should 
contain the following:

\begin{itemize}
\item Graphics - Anything that has to do with things being drawn on screen.
Tiles, Tilesets, portraits, backgrounds, etc.
\item Sound - Anything that causes noise. Background music, sound effects, and
anything else that falls into this category.
\item Text - Anything that can be written down in a natural language.
\item Maps - A composite that brings many of the aforementioned assets
together, to make up the virtual world.
\end{itemize}

Another aspect that we need to think along the way is how much modular we want 
the game engine to be. We need a balance between how much the engine provides
to the userbase, and how much the users need to work in order to get the game
as they want it. For example, some would be satisfied with a message box that 
provides the dialog with just plain text, and some might prefer a message box
that also has a portrait on the side. Additionally others would want the 
portraits to vary in emotional expressions. These are all very specialized
aspects, and pushes us towards a more stripped down product, but modular to
allow for these maneouvers. 

Due to the extreme modular requirements of such a software product, it might be
wiser to use a scripted programming language for the game engine. The rationale
being that retro RPG games don't require too much processing power in order to 
run, and another, the dynamic power of scripted programming languages, and an
indirect added benefit, the concise code that may be more accessible to the
userbase of the Haze game editor.

\subsection{Methods of Interaction (Input)}

Ultimately the editor and game engine should be able to be modular enough to 
specify different keys for different interactions. We do not want to hardcode
for example an ``action button'', a ``menu button'', and so forth. However we
can take into consideration the traditional joystick shown in Figure 
\ref{misc:joy}, and how such a minimalistic set of buttons have been able to
let the player interact fully with games over the timespan of at least 20 years,
we should probably provide the editor with default settings as such. Apart from
the test of time, I can not think of any logical reason why one would require
more controls than this, unless the userbase chooses to use other keys such as 
the function keys in order to access different menus - but this would increase
the learning curve of the game, rather than having everything accessible via
these said keys.

\psyfig{figures/misc/joy.png}%
       {Traditional Joystick}%
       {misc:joy}%
       {4in}

Let us list the buttons: 
\begin{itemize}
\item{A, B} buttons for standard actions. Usually `A' is used for confirmations
and `B' for cancellations.
\item{D-Pad (Directional Pad)} is a set of four buttons in essence that on
physical joysticks provides a physical mutual exclusion of each other from 
being pressed fown. This has to be taken into consideration when using a
keyboard since one is able to use any combination of buttons simultaneously.
\item{Start, Select} were usually used for menus and pausing the game. `Select'
is not as commonly used.
\end{itemize}

\subsection{Graphics}

In the respect of graphics, we want Haze to be a retro game engine. So in this
respect we will be interested mostly with the manipulation of 2d graphic files.
However blending in 3d aspects to 2d environments is totally possible and could
prove to be desirable by the userbase in the future.

For the graphics we require a library that can handle image manipulation. The
most important aspect being croping as we want to extract different tiles from
the tilesets that will exist in the assets. Just a simple reminder on some
jargon:

\paragraph{Tileset}: is an image file that contains smaller images that can be
used repeatedly as a pattern. 

\paragraph{Tile}: is a smaller graphic that is a pattern, that can be used to 
portray repeated graphics.

More trivially this part of the software should be able to load bigger pictures
such as portraits and backgrounds for the games. 

\subsection{Text}

Text is more important in role playing games as they traditionally are games
with richer storylines. Therefore it is even greater motivation to detect this
and prepare a proper mechanism.

A mechanism that has worked in the past in several applications I had to work
with and proved to be the right path to take in development, is
\textit{internationalization} and \textit{localization} of the system. Those 
are big words for simply meaning, storing the text of the application separately
and telling the system to look for an \textit{id} that containts the wanted 
text in that moment. 

A simple example would involve a menu asking your name. There would be a label
with the caption ``name''. For English speakers, that would be fine. But what
if someone wishes to use the application who does not know how to communicate
in that language? Should we make a copy of the project, and replace all the 
string instances with ``name'' and others to that other language? Or should we
factor out this functionality in some other way?

That is exactly where the said mechanisms come in, and we can have multiple
translations for the same application available, ready to update, and even add
more languages without the need of reloading the application. In the future if
let's say a game is made by this editor and engine, and it is accepted, we
would like to provide a means for translators to have no trouble to go about
their work.

\subsection{Sound}

Sound is pretty much anything that makes noise while the player is playing the
game. If more recent technology is to be used in order to write the music, then
I would suggest the use of Ogg Vorbis. The engine is open source and Ogg Vorbis
is pretty awesome when it comes to application.

For background music, we want to be able to loop the song. It would be also 
quite adventageous to point exactly where we want it to loop, as a song might
have an intro that is not repeated later on. I've seen this being omitted a few
many times and it's something that I personally did not like when I found it 
lacking.

Sound effects should be possible to mess around with effects. For example 
switching the pitch slightly for a repeating sound might make it sound less 
monotonous and not irritate the user as well. 

Also, another thing to take into consideration is voice actors, and games that
not only have the text of speech displayed, but actually can enabled it to have
the speech spoken out. This is another aspect of internationalization and 
localization that we need to take care off later on as well.

\subsection{Maps}

Maps are bits and pieces that build the world of the game. They are pretty
essential, and the correct analysis, design and implementation of them, in my
opinion, is critical. There's a lot of ways the maps can be expressed in a 
system, but many of these ways can be considered wrong or lacking.

When we boil it down to basics, there's two aspects we really need to look out
for. One of them are moving entities, and the others stills. A quality one has 
to deal with is also collisions, and appropriate actions to take on these 
collisions. Role playing games are very simple in this aspect (but we should
still provide a rich set of actions that may be performed for the sake of 
expressiveness of our users).

\subsubsection{Layers} 

Layers are the bread and butter in RPG maps. We want to provide rich maps in 
order for the user to explore. To provide these rich maps in the respect of 
graphics, we rely on transparency for pictures, and a layering system. Each
map can have a set of layers that describe the current location in pieces so
that if a character were to be behind a tile with a hole, only the visible part
of the player would be visible. The same technique can be used for other things
such as graphics. For example if we were to have two maps with the same ``tree
graphics'', but they had different backgrounds, we would not want to create two
different trees for this. That would waste space, and create extra work. Hence
in the tree graphics, we would make their background transparent in order to 
make them reusable with any background. 

\subsubsection{Portals} 

Portals connect maps together and make it possible for the player to travel 
between points. Portals could be placed as if they were NPCs in order to make 
the player move between maps, but should be implemented more flexible. For 
instance it should be a reusable function so that the player can either step 
on a tile to transport, or activate in a conversation with a NPC which would
teleport you instead. 

\subsubsection{Tiling}

The maps should be illustrated with tilesets. The tilesets should be on the 
same dialog of the map editor, as should be the aforementioned layers. A map
can be designed using many different tilesets. A good demonstration of the 
required layout to provide a comprehensive and usable interfacr to the user
is laid out in Figure \ref{ui:map-editor}


\psyfig{figures/ui/map-editor.png}%
       {Map Editor UI}%
       {ui:map-editor}%
       {5in}

\subsubsection{Storage format} 

We need to think about the following critical aspects: 

\begin{itemize} 
\item Storing paths to the tilesets
\item Storing the used tiles of each respective tileset in the map
\end{itemize} 

\subsection{Proposed Directory Structure for Assets}

We can outline a possible directory structure that should be standard for any
given game that would be created by the editor. Ultimately this should take
care of any file organization that is required by the userbase. We should keep
in mind that allowing the user to create their own directories for other assets
should also be taken into consideration.

\begin{lstlisting}
  /items.xml
  /graphics/tilesets
  /graphics/portraits
  /sounds/music
  /sounds/sfx
  /sounds/speech/en
  /sounds/speech/el - Example, a Hellenic voice translation
  /lang/en
  /lang/el - Example, a Hellenic translation
\end{lstlisting}

\subsection{Battle Mechanics}

RPGs are a little different to action games in respect to how the player is
challenged. In action games, the player is challenged to the actual (physical)
skills and reflexes the player learns to work with the game. For example, a
player that is good with action games, could finish an simple action game in
one shot, whereas in RPGs the skill is virtually accumulated in points for each
character, and leans more to mathematical models rather than skill in order to
challenge the player. Therefore some mechanism to support and supplement these
mathematical calculations would be required - that is, we want to make it fully
possible for the users to tweak or write their own functions, affected by 
different parameters in the game. 

Let us define two topics of interest for the following topics: 

\paragraph{Entity} is something that can interact in the map. Something more
than a wall for example. An NPC is an Entity. A treasure chest is an entity. A
wall is not an entity. A hidden door that can open up for the player to pass
through is an entity. Using this generalization makes for a stripped down,
and simple, reusable design. 

\paragraph{Attribute} an attribute is something that describes the abilities of
the entity. For example if the entity was of a `Fighter' class, there would 
exist an attribute that describes the Strength \textit{(STR)} of the character.

\subsubsection{Entity Attributes} 

Entity attributes describe the abilities of said entity. The mathematical model
provided in order to give a generic attribute system. We need to take into
consideration a short list of aspects for each attribute.

\begin{itemize}
  \item{Natural Amount} The natural amount of the entity (can not change)
  \item{Equipment Modifier} When equipment is held by the entity, there are
  modifications to the attributes. 
  \item{Race Modifier} The race that affects attributes to the entity. For
  example \textit{Elves} might have a \textit{(INT)} bonus, and a \textit{(STR)}
  penalty.
  \item{Buff Modifier} This is a temporary boost (or penalty) for the given
  attribute. For example if a wizard casts a protection spell, then more armor
  points migth be given to the entity. Same would be for a weaken spell.
\end{itemize}

Then the final use of the above attributes would be a simple summation.

% TODO Need to write the formula here
$$ \vec{Attributes} = [natural, equipment, race, buff] $$ 
$$ CurrentAttribute = \sum{Attributes} $$

\subsubsection{Entity Growth}

Some games take care of leveling up by themselves. For example, an entity might
be fixed in a ``Wizard'' class, so the statistics that would be accumulated for
each attribute would be preset; in other words the game would focus on adding 
many more points to the Intelligence \textit{(INT)} attribute on each level up.

Other games let the user choose the way the character levels up. For example
the entity is given the skilpoint and the player can then assign the
skillpoints to the wanted Entity Attributes.

\subsection{Component Diagrams}

The following component diagrams should give the reader an overview of what is
needed in order to achieve this vision. Figure \ref{component:generic} is a
generic overview of the components. Figure \ref{component:cxx11} is how the 
generic model can be realized with a programming language such as C++11.

\psyfig{figures/component/software-stack.png}%
       {Generic Software Stack}%
       {component:generic}%
       {7in}

\psyfig{figures/component/software-stack-cxx.png}%
       {Possible C++11 Software Stack}%
       {component:cxx11}%
       {7in}

