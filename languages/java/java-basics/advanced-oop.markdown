# Advanced Topics

In this section, we will talk about 'tricks' we can do with Object Oriented
programming. The 'tricks' we will use is to achieve grouping certain objects
together for common behavior, or extending an object in order to add more
functionality or specialize the object. We will go through various examples and
expand on these topics.

## Interfaces

We will begin, by showing how we can use interfaces of objects, we can change
the implementation in compile time as well as runtime to some extent, and still
have the application behave normally - without crashing.

For a more practical example think of a random number generator. The random
number generator could use a very common technique to generate random numbers.
Some techniques might purely be algorithmic. Other approaches may include
outside resources such as hard disks, mouse input, microphone input, and
anything that can aid you with providing 'real' random numbers.

In the context of OOP, you'd want a functionality that returns a random number
without caring too much what kind of things had to happen in the background in
order to get these numbers. So you'd want a method called `getRandom()`, which
returns a random number. Let's say that this random number is of type `integer`.

We can define the following specification of operations:

~~~~java
    public interface IRandomGenerator {
      int getRandom();
    }
~~~~

Notice that there are no visibility setters. When we define interfaces,
everything is public - you are defining _an interface_ after all. You might
notice that the name `IRandomGenerator` is prefixed with an `I`. This is a
common convention, to hint to the programmer that the type in question is in
fact an interface. Try to prefer this convention.

Now, any class, who's responsibility is to generate a random number, can
implement this interface. By implementing this interface, the user of any class
that implements the `RandomGenerator` interface will have the guarantee that the
`getRandom()` method exists, and will be callable.

Let's write our first implementation of of such an interface. For our naive
implementation, we're simply going to return the number `42`. We achieve this
with the following code snippet:

~~~~java
    public class NaiveRandomGenerator implements IRandomGenerator {
        @Override
        public int getRandom() {
            return 42;
        }
    }
~~~~

If we want something slightly more sophisticated, then we use `Java`'s random
library implementation in our alternate implementation of the interface. We can
do this by importing the `java.util.Random` package using the import keyword.
We create the class `BorrowedRandom` to achieve this alternate implementation:

~~~~java
    import java.util.Random;

    public class BorrowedRandom implements IRandomGenerator {
        @Override
        public int getRandom() {
            Random rand = new Random();
            return rand.nextInt() % 100;
        }
    }
~~~~

Finally let's test this out via a main method:

~~~~java
    public class Main {
        public static void main(String[] args) {
            IRandomGenerator rgen;

            rgen = new NaiveRandomGenerator();
            System.out.println(rgen.getRandom());

            rgen = new BorrowedRandom();
            System.out.println(rgen.getRandom());
        }
    }
~~~~

Notice: we are declaring an interface type in the beginning called `rgen`. It
would be impossible to invoke any operations on this object as this is an
interface - there is no implementation. The 'magic' happens later when we assign
a new object on the right hand side. We see the first occurrence in this line:

~~~~java
    rgen = new NaiveRandomGenerator();
~~~~

This is possible because `NaiveRandomGenerator` implements the interface we are
casting the object to. As does `BorrowedRandom`, and the reason you see the
second line, as a legal statement:

~~~~java
    rgen = new BorrowedRandom();
~~~~

Both will eventually execute `getRandom()`. However, during runtime, depending
on what we cast, we get the appropriate `getRandom()`. So, for the first line,
we will return `42` due to the naive implementation. On the second line, we will
always get random numbers, generated by `Java`'s random library. A simple run
gives us these values in the output prompt:

~~~~nocode
    42
    -68
~~~~

This means that you can have a dependency on some component in your software,
that could be changed at any time, which would not require you to go to all the
source to add these changes, since it respects that common interface. On top of
that, we could change the behavior during runtime, by alternating between
objects, which implement this common interface.

Would it be possible however, to add some sort of implementation details and
behavior to interfaces, but retain this 'dynamic switching' between objects? The
answer is yes. You achieve this through polymorphism, though the rules are
slightly different in this case.

## Polymorphism

Polymorphism follows very similar steps to that of interfaces, only that instead
of interfaces, we are extending a class. In abstract terms, we have some `class
A`, that exhibits features `{k, l, m, n}`. If we were to extend `class A` via
`class B`, and `class B` exhibited features `{o, p}`, then the features that
`class B` would have in total would be `{k, l, m, n, o, p}`. This is called
'inheritance' and happens when we extend one class via another. Let's take a
look at the following code snippet:

~~~~java
    public class Animal {
        public float getBodyTemperature() {
            return 37.5f;
        }
        public void talk() {
            System.out.println("I am an awesome animal");
        }
    }
~~~~

Now, to extend this class, we need to use the keyword `extends`. We will do this
with a class called `Cat`. This is how you inherit from a parent class.

~~~~java
    public class Cat extends Animal {
    }
~~~~

In the above class we're not really adding anything. This is purely for
demonstration purposes. We can observe then, that if we do the following, the
program would compile, and nothing out of the ordinary happens, since `Cat` has
all the features of `Animal`.

~~~~java
    public class Main {
        public static void main(String[] args) {
            Animal a = new Animal();
            Cat c = new Cat();

            System.out.println(a.getBodyTemperature());
            System.out.println(c.getBodyTemperature());
            a.talk();
            c.talk();
        }
    }
~~~~

### Adding New Functionality

Of course, we could add more functionalities to the `Cat` class. This would mean
that apart from all the features obtained from the parent class `Animal`, `Cat`
would have extra functionalities as well.

~~~~java
    public class Cat extends Animal {
        public void scratchFurniture() {
            System.out.println("HA HA HA HUMAN");
        }
    }
~~~~

Again the following would be legal:

~~~~java
    public class Main {
        public static void main(String[] args) {
            Animal a = new Animal();
            Cat c = new Cat();

            System.out.println(a.getBodyTemperature());
            System.out.println(c.getBodyTemperature());

            a.talk();
            c.talk();
            c.scratchFurniture();
        }
    }
~~~~

However, the following line would not be legal, since `Animal` does not
implement the method `scratchFurniture()`. Only the class `Cat` in this context
can scratch furniture:

~~~~java
    Animal a = new Animal();
    a.scratchFurniture(); /* Does not compile */
~~~~

### Overloading

A brief reminder of Overloading: overloading is when we have two functions that
return the same type, and have the same name, but differ in the parameters they
actually take in, be it type of parameters, and number of parameters. So for
example, these two functions are overloaded:

~~~~java
    class MyClass {
      public int myMethod() {
        return 42;
      }

      public int myMethod(int i, int j) {
        return i + j;
      }
    }
~~~~

### Overriding

Overriding exists as a result of Polymorphic types. Recall the previous
discussion about having a `class A` with features `{k, l, m, n}`, and extending
it via `class B` with features `{o, p}`, resulting in all the features `{k, l,
m, n, o, p}` available to `class B`. So now the question is, if we have a `class
C`, with features `{a, b}`, and `class D` with similar feature `{b}`, then which
`b` is the `b` that will be used? The short answer, is the `b` of `class D` will
be used. It can get more complicated however.

In less abstract terms, consider a `class A` which has method `void talk()`. We
extend `class A` via `class B`. In `class B` we add again, the method `void
talk()`. What happens now? When we instantiate this class, which method actually
runs? Below is the code represented in Java:

~~~~java
    public class A {
        public void talk() { System.out.println("Hello from A"); }
    }

    /* ... */

    public class B {
        @Override
        public void talk() { System.out.println("B B B B B"); }
    }
~~~~

If we perform the following:

~~~~java
    public class Main {
        public static void main(String[] args) {
            A ab = new B();
            ab.talk();
        }
    }
~~~~

The result is going to be:

~~~~nocode
    B B B B B
~~~~

So, extending the parent class `A`, and in the subclass `B` adding the same
method with the same method parameters and return time, we can get `rid` of the
parent's behavior. Getting `rid` - Over-rid-ing. Let us examine the above in a
little more detail. First you might notice this line:

~~~~java
    A ab = new B();
~~~~

This is possible because of rules similar to that of the interface - we know
that `B` implements whatever the interface of `A` is. Therefore, when we call
for an operation on `ab`, we know that the operation will be either found first
in `B`, or eventually up in its superclass `A`. Therefore we can cast a `B`
instantiated object onto a type, declared as `A`. In essence you need to observe
two things with the above: the left hand side `ab` is the declared type, which
is of type `A`, and the right hand side is of dynamic type `B`.

One might ask _Why would we do such a thing?_ And again the answer would be very
similar to that of interfaces: to interchangeably be able to switch one object,
with another for the implementation. This would provide you, as stated in the
interface section, two things: being able to change some implementation in the
static time during compilation, and switching between objects with different
implementations in the runtime. The difference however is that we can reuse
implementation when extending a class - something not possible with interfaces.
In classes you could extend a class, and `override` functionalities you would
want different. In interfaces, you would have to re-implement everything for
each class that implemented that interface.

### Protected Visibility and Inheritance

You may recall the `protected` visibility we talked about previously. When we
have a class with `private` features, we are unable to call these features from
the outside, from another method. Also if we extend that class, then in the
child class we would be also unable to access these features. What about a
visibility that would disallow outside callers from seeing such features, whilst
providing the child classes with the parent's features? This type of visibility
is called `protected`.

If we had the following code, the operations would be legal:

~~~~java
    public class Parent {
      protected void doThings() { /* ... */ }
    }

    /* ... */

    public class Child extends Parent {
      public void myMethod() {
        doThings();
      }
    }

~~~~


