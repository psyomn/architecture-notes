## Classes vs Objects

A good thing to do at this point is to differentiate between what classes and
objects are. Classes are the definition. Objects are the result.

Another analogy would be the following: imagine spheres of different sizes and
color. They all belong to a same family. But each one of them, with the same
questions, will yield different results. For example, any two elements `A` and
`B` are spheres. However they may be of different color. A better example would
be to classify them with respect to behavior: all of them will respect the
formula, that gives us the area of a sphere. The only information required, is
the size of their radius: in other words given some differing information of a
radius `r`, we may apply the same function for any `r`, and get the required
behavior.

So, in other words, a class may contain crucial behavioral definitions, whereas
objects contain the differing information that the behavior requires. More
abstract, classes are specifications, whereas objects are instantiations of
those specifications, possibly given differing data.

The user has control over both classes and objects. Here is a simple class:

~~~~java
class Sphere {
  public Sphere(float iRadius, String iColor) {
    mRadius = iRadius;
    mColor  = iColor;
  }
  public String color() { return mColor; }
  public float area() { return 4 * Math.PI * Math.power(mRadius, 3); }
  private String mColor;
  private float mRadius;
}
~~~~

You can see what was previously described in code form. We have set behavior
for the Sphere we modeled. Now it will behave according to what `radius` we
supply to the object, instantiated from the class. To instantiate an object,
we may do the following:

~~~~java
public class Main {
  public static void main(String[] args) {
    Sphere s = new Sphere(3.2, "red");
    Sphere r = new Sphere(4.8, "blue");
    System.out.println(s.area());
    System.out.println(r.area());
  }
}
~~~~

If we were to visualize this in the memory space, we could see these two objects
as the following:

~~~~nocode
    +--------+   +--------+
    | Sphere |   | Sphere |
    +--------+   +--------+
    | 3.2    |   | 4.8    |
    | "red"  |   | "blue" |
    +--------+   +--------+
~~~~

And using the declared method `area`, we would be able to 'send a message' to
these objects in memory. Both of them know about the method `area`, and what
actions to take (see the implementation of `area()` in the code listing). What
these objects need to do is 'plug in' the variables they hold to their
respective `instance variable` declarations. So when calculating the area of the
red sphere, we would want the radius of `3.1` to be plugged in the formula.
However, when calling area for the "blue" sphere, we wish to 'plug in' `4.8` as
the value of the radius.

Essentially you should think of objects as entities, that know about what their
structure is like (what data fields they have, and what behavior), and which
behave differently whenever given different data. There can be many 'entities'
expressing this behavior at any given time.

Now let us look at the more practical side of things. It is assumed that the
reader is familiar with procedural programming. We will write the following in
`C` code to demonstrate our point. Recall that in C we do not have classes, but
structures which are strictly used to hold data. The functionality comes from
providing many free functions with knowledge on how to manipulate the data. So
the equivalent to the above example with the spheres would be something like the
following:

~~~~C
    typedef struct {
      float    radius;
      uint32_t color_code;
    } sphere_t;

    void
    sphere_set_radius(sphere_t* _s, float _r) {
      _s->radius = _r;
    }

    float
    sphere_calculate_area(sphere_t* _s) {
      return _s->radius * _s->radius * 3.142 * 4;
    }
~~~~

You can notice that on the above, both functions would require a reference to
the structure we are dealing with. That particular structure is omitted from the
type signatures in most object oriented languages, and a keyword called `this`
is provided, if the particular behavior of a class needs to refer to that
particular object in the runtime.

## Visibility

In `C` programs we don't quite have the notion of visibility. We have something
similar in the respect of static declarations in objects (by objects I'm
refering to the object code generated by the compiler, usually having the `.o`
suffix), but that is not what we are talking about.

Take the C structure in the following fragment:

~~~~C
    typedef struct {
      int age;
      float salary;
    } person_t;
~~~~

If we had the following function, accessing members of the struct would be
legal:

~~~~C
    void my_func(person_t* _person) {
      /* Given that _ms is non-null */
      _person->myint = 1;
      _person->fval  = 2.32f;
    }
~~~~

### Private Visibility

In object oriented languages we are able to restrict this visibility. The
motivation is to provide an agnostic way of handling data 'behind the scenes',
whilst providing a _standard interface_ to the application programmer, using
this unit. In Java, one is required to use the `private` keyword for restricting
this visibility. If this restriction is not required, and some feature (either a
method, or a variable) is to be called directly, then we can use the `public`
keyword. The above could be translated to the following Java code, if we wished
to restrict the visibility to the two variables:

~~~~Java
    class Person {
      private Integer age;
      private Float salary;
    }
~~~~

If an application developer tried using the above class, and calling the
attributes directly, there would be a compilation error:

~~~~Java
    Person p = new Person();
    System.out.println(p.age); /* Does not compile */
~~~~

### Public Visibility

As we previously saw, we can declare different parts of a class as public. For
example the following class has a few of it's attributes as public:

~~~~java
    class Person {
      public String name;
      public String surname;
    }
~~~~

This means that we can directly access the data from some other part in the
program in such a fashion:

~~~~java
    public class Main {
      public static void main(String[] args) {
        Person p = new Person();
        p.name = "jonny";
        p.surname = "overload";

        System.out.println(p.name);
        System.out.println(p.surname);
      }
    }
~~~~

One might notice and pose the following question: _if I can simply access the
data that I require using public visibility, why not use public everywhere?_

You could technically use public everywhere. But you would sacrifice one
mechanism that you might not want to otherwise: you treat objects as black boxes
which you do not care how things are implemented on the other side - but you
know what the output is.

### Why Private Visibility

To the users of some component in your software, expressed as a class, you want
to publicize methods which are relevant to the problem that user of the class
wants to solve. For instance, take the example of our previous example of the
`Sphere`. Our user would only care about the particular function that returns
the _color_ of the `Sphere`, or the _area_. In the inside of the class, we might
split into different functions different procedures we need to do until we reach
our final answer. For example the `getColor()` method might call other functions
to finally return the color to the user, and these functions could be of no
particular interest to the user.

For a more concrete example, let us consider the case that `getColor()` should
return the color label as a string, but all the letters should be in capitals.
Inside the Sphere class we would have a function called `capitalize`, which
would capitalize strings. The user would not care about such a thing, but the
functionality in the class, would require such an operation. Using `private`
visibility we are able to hide this information such that the user of the
`Sphere` class would not know of such functionality.

A more realistic example would be if the `getArea()` functionality required more
complex calculations which could be split up into smaller units, allowing for
different optimizations to be made. The user of the class is interested in
knowing about the `getArea()` operation, regardless of the implementation.

### Protected Visibility

Protected visibility is something we will cover once we cover an advanced topic
later on. For now it is sufficient to know that the visibilities which exist
are:

* Public visibility

* Private visibility

* Protected visibility

## Creating a Small Application

When you want to create a small application, you essentially want to break down
different functionalities in different classes. In other words, if you choose a
good granularity on how much you break these functionalities down, the easier
your life will be on the development side of things.

Let's look into creating a small application, where we implement an address
book. The address book will hold names, surnames, and emails. The user will be
prompted to enter different information for different situations.  We would like
to:

- Have a menu to choose whether to:
    - Create an entry of a person.
    - Lookup the information of a person.

We should worry about two things: separating the structures which may hold this
information, to the user interface that interacts with these structures.
Essentially you want to separate these two things to two or more classes.

Let's first begin with our data classes, in other words our conceptual domain.
We are interested in the three data fields: name, surname, and email.

Writing this down we first get the following:

~~~~java
    class Person {
      private String name;
      private String surname;
      private String email;
    }
~~~~

We notice that the above attributes are private. How is the user of the class
supposed to set these values now? We use getters and setters. The getters return
the values of the attributes, and the setters overwrites or sets them. These
operations are defined with public visibility instead. In code we can simply
show this as such:

~~~~java
    class Person {
      private String name;
      private String surname;
      private String email;

      public String getName() {
        return name;
      }

      public String getSurname() {
        return surname;
      }

      public String getEmail() {
        return email;
      }

      public void setName(String name) {
        this.name = name;
      }

      public void setSurname(String surname) {
        this.surname = surname;
      }

      public void setEmail(String email) {
        this.email = email;
      }
    }
~~~~

We pretty much have a structure to hold the information we want for a person.
Now we want an `AddressBook`, which will store this information. Essentially, we
want to have a method to add people, and remove people. Let's call these methods
`addPerson()` and `removePerson()` respectively. We will have an extra method
that looks up a person by name, and if found, it will print all that information
of that person. Else, there will be an error message printed. We call such
method `findPerson()`.

To store each person, we will need a data structure. The data structure we will
choose for this particular example will be an `ArrayList`. An `ArrayList` may
expand or shrink depending on the information given. To add objects to the data
structure, we call `add()`. To remove objects from the list we call `remove()`.
There is one final thing that we need to do: tell the structure that we will be
storing `Person` objects. The reason to this, we will see later in the
`Templates` section. To tell the structure `ArrayList` we are storing `Person`
objects, we show this by adding it between angled brackets.

~~~~java
    public class AddressBook {

        public void addPerson(Person person) {
            people.add(person);
        }

        public void findPersonByName(String name) {
            for (Person p : people) {
                if (p.getName().equalsIgnoreCase(name)) {
                    System.out.println("Found:");
                    System.out.println("Name:    " + p.getName());
                    System.out.println("Surname: " + p.getSurname());
                    System.out.println("Email:   " + p.getEmail());
                    return; /* Stop searching in list */
                }
            }
            System.out.println("Nothing found!");
        }

        private ArrayList<Person> people = new ArrayList<Person>();
    }
~~~~

With this code, we're able to store all of our wanted information somewhere,
add, and remove as needed, and search. Finally we want a final class that will
handle the input and output interactions with the user.  Essentially this is the
interface of our application. Since we're not providing anything graphical, this
is a command line interface. We will name this class `AddressBookController`.

We provide a command line interface by using `Scanner`. Scanner provides
different methods to receive input. We specify what we expect by using the right
operation. For example if we want an integer, we would call `nextInteger()`, if
we wanted a double floating point number, we would call `nextDouble()`. Since
we're scanning in Strings, we use `nextLine()`. This will make sure that
anything typed in, until the user hits the return key, will be scanned in. On
the other hand, if a simple `next()` was used, then it would parse in just the
first word which would be delimited by a space.

The code below shows what our controller would look like.

~~~~java
    public class AddressBookController {
        public void run() {
            String cmd = "default";
            Scanner scan = new Scanner(System.in);

            while (!cmd.equalsIgnoreCase("end")) {
                System.out.print("> ");
                cmd = scan.nextLine();
                cmd = cmd.trim();

                if (cmd.equalsIgnoreCase("insert")) {
                    Person p = new Person();
                    System.out.print("Person name: ");
                    p.setName(scan.nextLine());

                    System.out.print("Person surname: ");
                    p.setSurname(scan.nextLine());

                    System.out.print("Person email: ");
                    p.setEmail(scan.nextLine());

                    addressBook.addPerson(p);
                }
                else if (cmd.equalsIgnoreCase("find")) {
                    System.out.print("Name of person: ");
                    String name = scan.nextLine();
                    name = name.trim();
                    addressBook.findPersonByName(name);
                }
                else if (cmd.equalsIgnoreCase("help")) {
                    System.out.println(
                      "insert - insert a person's details into the address book\n" +
                      "find   - find a person by name\n" +
                      "end    - quit this application\n");
                }
                else if (cmd.equalsIgnoreCase("end")) {
                    continue;
                }
                else {
                    System.out.println("No such command");
                }
            }
        }

        private AddressBook addressBook = new AddressBook();
    }
~~~~

Finally we just need an entry point for our application:

~~~~java
    public class Main {
        public static void main(String[] args) {
            AddressBookController abc = new AddressBookController();
            abc.run();
        }
    }
~~~~

If we run it and try some input, we get the following:

~~~~nocode
    > help
    insert - insert a person's details into the address book
    find   - find a person by name
    end    - quit this application

    > insert
    Person name: jon
    Person surname: jonson
    Person email: jon@son.com
    > find
    Name of person: jon
    Found:
    Name:    jon
    Surname: jonson
    Email:   jon@son.com
    > find
    Name of person: potato
    Nothing found!
    > end
~~~~


